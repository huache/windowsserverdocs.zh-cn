---
title: for
description: For 命令的参考文章，用于在一组文件中为每个文件运行指定的命令。
ms.topic: reference
ms.assetid: e275726c-035f-4a74-8062-013c37f5ded1
author: coreyp-at-msft
ms.author: coreyp
manager: dongill
ms.date: 10/16/2017
ms.openlocfilehash: 7120ed613595b5b90334e49b0865c3e598f3cabb
ms.sourcegitcommit: 96d46c702e7a9c3a321bbbb5284f73911c7baa3c
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/27/2020
ms.locfileid: "89027635"
---
# <a name="for"></a>for

为每个文件在一组文件中运行指定的命令。

## <a name="syntax"></a>语法

```
for {%% | %}<variable> in (<set>) do <command> [<commandlineoptions>]
```

### <a name="parameters"></a>参数

| 参数 | 说明 |
| --------- | ----------- |
| `{%% | %}<variable>` | 必需。 表示可替换参数。 使用单个百分号 (`%`) 在命令提示符下执行 **for** 命令。 使用双百分号 (`%%`) 在批处理文件中执行 **for** 命令。 变量区分大小写，并且必须使用字母值（如 **% a**、 **% b**或 **% c**）来表示。 |
| (`<set>`) | 必需。 指定要对其运行命令的一个或多个文件、目录或文本字符串或值的范围。 需要使用括号。 |
| `<command>` | 必需。 指定要在每个文件、目录或文本字符串上执行的命令，或在 *set*中包含的值的范围内执行的命令。 |
| `<commandlineoptions>` | 指定要与指定命令一起使用的任何命令行选项。 |
| /? | 在命令提示符下显示帮助。 |

#### <a name="remarks"></a>注解

- 可以在批处理文件中或直接从命令提示符中使用此命令。

- 以下属性适用于 **for** 命令：

  - 此命令会 `% variable` 将或替换为 `%% variable` 指定集中的每个文本字符串，直到指定的命令处理所有文件。

  - 变量名称区分大小写，全局，并且每次只能激活52。

  - 若要避免与批处理参数混淆， `%0` `%9` 可以使用除数字**0**到**9**之外*的*任何其他字符。 对于简单的批处理文件，可使用的单个字符 `%%f` 。

  - 可以在复杂的批处理文件中使用 *变量* 的多个值，以区分不同的可替换变量。

- *Set*参数可以表示一组文件或多组文件。 您可以使用通配符 (**&#42;** 和 **？**) 来指定文件集。 下面是有效的文件集：

  ```
  (*.doc)
  (*.doc *.txt *.me)
  (jan*.doc jan*.rpt feb*.doc feb*.rpt)
  (ar??1991.* ap??1991.*)
  ```

- 使用此命令时，set 中的第一个值 *将* 替换 `% variable` 或 `%% variable` ，然后指定的命令将处理此值。 此过程将一直继续，直到处理完所有文件 (或文件组与 *设置* 值对应的) 。

- **在和中** ， **不** 使用参数，但必须在此命令中使用它们。 如果省略其中任一关键字，则会显示错误消息。

- 如果 (默认) 启用命令扩展，则支持 **以下的附加** 形式：

  - **仅目录：** 如果 *set* (**&#42;** 或 **？**) 包含通配符，则会对每个 (目录执行指定的 *命令* ，而不是对指定目录中的一组文件) 匹配 *集*。 语法为：

    ```
    for /d {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
    ```

  - **Recursive：** 遍历位于 *drive*：*path* 的根目录树，并在树的每个目录中执行 **for** 语句。 如果在 **/r**之后未指定目录，将使用当前目录作为根目录。 如果 *set* 只是一个句点 ( ) ，则只会枚举目录树。 语法为：

    ```
    for /r [[<drive>:]<path>] {%%|%}<variable> in (<set>) do <command> [<commandlinepptions>]
    ```

  - **迭代一系列值：** 使用迭代变量设置起始值 (*start*# ) ，然后逐步遍历一组值，直到值超过设置结束值 (*end*# ) 。 **/l** 将 *开始*# 与 *结束*# 进行比较，以执行迭代。 如果 *start*# 小于命令将执行的 *结束*#。 当迭代变量超过 *end*# 时，命令外壳将退出该循环。 还可以使用负 *步骤*# 单步执行递减值中的范围。 例如， (1，1，5) 生成序列 1 2 3 4 5， (5，-1，1) 生成序列 5 4 3 2 1。 语法为：

    ```
    for /l {%%|%}<variable> in (<start#>,<step#>,<end#>) do <command> [<commandlinepptions>]
    ```

  - **迭代和文件分析：** 使用文件分析处理命令输出、字符串和文件内容。 使用迭代变量定义要检查的内容或字符串，并使用各种 *parsingkeywords* 选项进一步修改分析。  使用 *parsingkeywords* 标记选项可指定哪些标记应作为迭代变量传递。 请注意，当不使用令牌选项时， **/f** 将仅检查第一个令牌。

    文件分析包括读取输出、字符串或文件内容，然后将其分解为单独的文本行，并将每一行分析为零个或多个标记。 然后，将调用 **for** 循环，并将迭代变量值设置为标记。 默认情况下， **/f** 从每个文件的每一行传递第一个空格分隔标记。 将跳过空白行。

    语法为：

    ```
    for /f [<parsingkeywords>] {%%|%}<variable> in (<set>) do <command> [<commandlinepptions>]
    for /f [<parsingkeywords>] {%%|%}<variable> in (<literalstring>) do <command> [<commandlinepptions>]
    for /f [<parsingkeywords>] {%%|%}<variable> in ('<command>') do <command> [<commandlinepptions>]
    ```

    *Set*参数指定一个或多个文件名。 在移动到 *集*内的下一个文件之前，将打开、读取和处理每个文件。 若要覆盖默认的分析行为，请指定 *parsingkeywords*。 这是一个带引号的字符串，其中包含一个或多个用于指定不同分析选项的关键字。

    如果使用 **usebackq** 选项，请使用以下语法之一：

    ```
    for /f [usebackq <parsingkeywords>] {%%|%}<variable> in (<Set>) do <command> [<commandlinepptions>]
    for /f [usebackq <parsingkeywords>] {%%|%}<variable> in ('<LiteralString>') do <command> [<commandlinepptions>]
    for /f [usebackq <parsingkeywords>] {%%|%}<variable> in (`<command>`) do <command> [<commandlinepptions>]
    ```

    下表列出了可用于 *parsingkeywords*的分析关键字。

    | 关键字 | 说明 |
    | ------- | ----------- |
    | eol =`<c>` | 指定仅 (一个字符) 的行尾字符。 |
    | skip =`<n>` | 指定文件开头要跳过的行数。 |
    | delims =`<xxx>` | 指定分隔符集。 这将替换空格和制表符的默认分隔符集。 |
    | 标记 =`<x,y,m–n>` | 指定每行的哪些标记要传递到每个迭代的 **for** 循环。 因此，将分配更多的变量名称。 *m-n* 指定从 *m*到第 *n*个标记的范围。 如果 **标记 =** 字符串中的最后一个字符为星号 (**&#42;**) ，则分配一个额外的变量，并在分析的最后一个标记之后的行上接收剩余的文本。 |
    | usebackq | 指定以命令形式运行带引号的字符串，将带引号的字符串用作文本字符串; 或者，对于包含空格的长文件名，允许在中使用文件名， `<set>` 每个名称都括在双引号中。 |

  - **变量替换：** 下表列出了 ** () 的** 任何变量的可选语法：

    | 带有修饰符的变量 | 说明 |
    | ---------------------- | ----------- |
    |` %~I` | 展开 `%I` 可删除任何周围引号。 |
    | `%~fI `| 扩展 `%I` 到完全限定的路径名称。 |
    | `%~dI `| `%I`仅扩展到驱动器号。 |
    | `%~pI` | `%I`仅展开为路径。 |
    | `%~nI `| `%I`仅扩展到文件名。 |
    | `%~xI` | `%I`仅扩展到文件扩展名。 |
    | `%~sI` | 将路径展开为仅包含短名称。 |
    | `%~aI` | 扩展 `%I` 到文件的文件属性。 |
    | `%~tI` | 扩展 `%I` 到文件的日期和时间。 |
    | `%~zI` | 扩展 `%I` 到文件的大小。 |
    | `%~$PATH:I` | 搜索 PATH 环境变量中列出的目录，并将其扩展 `%I` 到找到的第一个目录的完全限定名称。 如果未定义环境变量名称或搜索找不到该文件，此修饰符将扩展为空字符串。 |

    下表列出了可用于获取复合结果的修饰符组合。

    | 包含组合修饰符的变量 | 说明 |
    | -------------------------------- | ----------- |
    | `%~dpI `| `%I`仅扩展到驱动器号和路径。 |
    | `%~nxI` | `%I`仅扩展到文件名和扩展名。 |
    | `%~fsI` | `%I`将扩展为仅带有短名称的完整路径名称。 |
    | `%~dp$PATH:I` | 搜索 PATH 环境变量中列出的目录，并将其 `%I` 扩展到找到的第一个驱动器号和路径。 |
    | `%~ftzaI` | 展开 `%I` 为类似于 **dir**的输出行。 |

    在上述示例中，可以将替换 `%I` 为其他有效值，并将其替换为路径。 **变量名称**的有效结尾为 **%~** 语法。

    通过使用大写变量名称（如 `%I` ），可以使代码更具可读性，并避免与不区分大小写的修饰符混淆。

- **分析字符串：** 可以 `for /f` 通过以下两种方式使用分析逻辑 `<literalstring>` ：双引号：双引号 (*不带* usebackq 的双引号) 或单引号 (*使用* usebackq) --例如， (MyString) 或 ( "MyString" ) 。 `<literalstring>` 被视为来自文件的单个行输入。 当 `<literalstring>` 在双引号中进行分析时，命令符号 (例如， `\ & | > < ^`) 被视为普通字符。

- **分析输出：** 您可以使用 `for /f` 命令来分析命令的输出，方法是在括号之间放置一个反引号 `<command>` 。 它被视为传递到子 Cmd.exe 的命令行。 将输出捕获到内存中，并将其作为文件进行分析。

## <a name="examples"></a>示例

若要 **在批处理** 文件中使用，请使用以下语法：

```
for {%%|%}<variable> in (<set>) do <command> [<commandlineoptions>]
```

若要使用可替换变量 **% f**显示当前目录中所有文件的内容，该文件的扩展名为 .doc 或 .txt，请键入：

```
for %f in (*.doc *.txt) do type %f
```

在前面的示例中，当前目录中具有 .doc 或 .txt 扩展名的每个文件都将替换 **% f** 变量，直到显示每个文件的内容。 若要在批处理文件中使用此命令，请将 **% f** 的每个匹配项替换为 **%% f**。 否则，将忽略该变量并显示一条错误消息。

若要分析文件，忽略注释行，请键入：

```
for /f eol=; tokens=2,3* delims=, %i in (myfile.txt) do @echo %i %j %k
```

此命令分析 *myfile.txt*中的每行。 它将忽略以分号开头的行，并将每一行的第二个和第三个令牌传递 **给正文 (** 标记以逗号或空格分隔) 。 **For**语句的主体引用 **% i**获取第二个标记， **% j**获取第三个标记，并为 **% k**以获取所有剩余标记。 如果提供的文件名包含空格，请使用引号将文本括 (例如，文件名) 。 若要使用引号，必须使用 **usebackq**。 否则，引号被解释为定义要分析的文本字符串。

已在**for**语句中显式声明了 **% i** 。 **% j** 和 **% k** 使用 **标记 =** 隐式声明。 您可以使用 **标记 =** 来指定最多26个标记，前提是它不会导致将变量声明为大于字母 Z 或 z 的尝试。

若要分析命令的输出，请 *将集* 放在括号之间，键入：

```
for /f usebackq delims== %i in ('set') do @echo %i
```

## <a name="additional-references"></a>其他参考

- [命令行语法项](command-line-syntax-key.md)
