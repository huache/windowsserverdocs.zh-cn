---
title: 针对
description: For 命令的参考主题，该主题针对每个文件在一组文件中运行指定的命令。
ms.prod: windows-server
ms.technology: manage-windows-commands
ms.topic: article
ms.assetid: e275726c-035f-4a74-8062-013c37f5ded1
author: coreyp-at-msft
ms.author: coreyp
manager: dongill
ms.date: 10/16/2017
ms.openlocfilehash: 24ef5bc159e67862d419bd2728b14585f8b095d4
ms.sourcegitcommit: bf887504703337f8ad685d778124f65fe8c3dc13
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/16/2020
ms.locfileid: "83437012"
---
# <a name="for"></a>针对

为每个文件在一组文件中运行指定的命令。

## <a name="syntax"></a>语法

```
for {%% | %}<variable> in (<set>) do <command> [<commandlineoptions>]
```

### <a name="parameters"></a>参数

| 参数 | 说明 |
| --------- | ----------- |
| `{%% | %}<variable>` | 必需。 表示可替换参数。 使用单个百分号（ `%` ）在命令提示符下执行**for**命令。 使用双百分号（ `%%` ）在批处理文件中执行**for**命令。 变量区分大小写，并且必须使用字母值（如 **% a**、 **% b**或 **% c**）来表示。 |
| (`<set>`) | 必需。 指定要对其运行命令的一个或多个文件、目录或文本字符串或值的范围。 需要使用括号。 |
| `<command>` | 必需。 指定要在每个文件、目录或文本字符串上执行的命令，或在*set*中包含的值的范围内执行的命令。 |
| `<commandlineoptions>` | 指定要与指定命令一起使用的任何命令行选项。 |
| /? | 在命令提示符下显示帮助。 |

#### <a name="remarks"></a>备注

- 可以在批处理文件中或直接从命令提示符中使用此命令。

- 以下属性适用于**for**命令：

  - 此命令会 `% variable` 将或替换为 `%% variable` 指定集中的每个文本字符串，直到指定的命令处理所有文件。

  - 变量名称区分大小写，全局，并且每次只能激活52。

  - 若要避免与批处理参数混淆， `%0` `%9` 可以使用除数字**0**到**9**之外*的*任何其他字符。 对于简单的批处理文件，可使用的单个字符 `%%f` 。

  - 可以在复杂的批处理文件中使用*变量*的多个值，以区分不同的可替换变量。

- *Set*参数可以表示一组文件或多组文件。 您可以使用通配符（**&#42;** 和 **？**）来指定文件集。 下面是有效的文件集：

  ```
  (*.doc)
  (*.doc *.txt *.me)
  (jan*.doc jan*.rpt feb*.doc feb*.rpt)
  (ar??1991.* ap??1991.*)
  ```

- 使用此命令时，set 中的第一个值*将*替换 `% variable` 或 `%% variable` ，然后指定的命令将处理此值。 这将继续，直到处理完所有与*集*值相对应的文件（或文件组）。

- **在和中**，**不**使用参数，但必须在此命令中使用它们。 如果省略其中任一关键字，则会显示错误消息。

- 如果启用了命令扩展（这是默认设置），则支持**以下的附加**形式：

  - **仅目录：** 如果*set*包含通配符（**&#42;** 或 **？**），则会对每个目录（而不是指定目录中的一组文件）执行指定的*命令*，以匹配*集*。 语法为：

    ```
    for /d {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
    ```

  - **Recursive：** 遍历位于*drive*：*path*的根目录树，并在树的每个目录中执行**for**语句。 如果在 **/r**之后未指定目录，将使用当前目录作为根目录。 如果*set*只是一个句点（.），则它仅枚举目录树。 语法为：

    ```
    for /r [[<drive>:]<path>] {%%|%}<variable> in (<set>) do <command> [<commandlinepptions>]
    ```

  - **迭代一系列值：** 使用迭代变量设置起始值（*start*#），然后单步执行一组值，直到值超过设置的结束值（*end*#）。 **/l**将*开始*# 与*结束*# 进行比较，以执行迭代。 如果*start*# 小于命令将执行的*结束*#。 当迭代变量超过*end*# 时，命令外壳将退出该循环。 还可以使用负*步骤*# 单步执行递减值中的范围。 例如，（1，1，5）生成序列 1 2 3 4 5，（5，-1，1）生成序列 5 4 3 2 1。 语法为：

    ```
    for /l {%%|%}<variable> in (<start#>,<step#>,<end#>) do <command> [<commandlinepptions>]
    ```

  - **迭代和文件分析：** 使用文件分析处理命令输出、字符串和文件内容。 使用迭代变量定义要检查的内容或字符串，并使用各种*parsingkeywords*选项进一步修改分析。  使用*parsingkeywords*标记选项可指定哪些标记应作为迭代变量传递。 请注意，当不使用令牌选项时， **/f**将仅检查第一个令牌。

    文件分析包括读取输出、字符串或文件内容，然后将其分解为单独的文本行，并将每一行分析为零个或多个标记。 然后，将调用**for**循环，并将迭代变量值设置为标记。 默认情况下， **/f**从每个文件的每一行传递第一个空格分隔标记。 将跳过空白行。

    语法为：

    ```
    for /f [<parsingkeywords>] {%%|%}<variable> in (<set>) do <command> [<commandlinepptions>]
    for /f [<parsingkeywords>] {%%|%}<variable> in (<literalstring>) do <command> [<commandlinepptions>]
    for /f [<parsingkeywords>] {%%|%}<variable> in ('<command>') do <command> [<commandlinepptions>]
    ```

    *Set*参数指定一个或多个文件名。 在移动到*集*内的下一个文件之前，将打开、读取和处理每个文件。 若要覆盖默认的分析行为，请指定*parsingkeywords*。 这是一个带引号的字符串，其中包含一个或多个用于指定不同分析选项的关键字。

    如果使用**usebackq**选项，请使用以下语法之一：

    ```
    for /f [usebackq <parsingkeywords>] {%%|%}<variable> in (<Set>) do <command> [<commandlinepptions>]
    for /f [usebackq <parsingkeywords>] {%%|%}<variable> in ('<LiteralString>') do <command> [<commandlinepptions>]
    for /f [usebackq <parsingkeywords>] {%%|%}<variable> in (`<command>`) do <command> [<commandlinepptions>]
    ```

    下表列出了可用于*parsingkeywords*的分析关键字。

    | 关键字 | 说明 |
    | ------- | ----------- |
    | eol =`<c>` | 指定行尾字符（仅一个字符）。 |
    | skip =`<n>` | 指定文件开头要跳过的行数。 |
    | delims =`<xxx>` | 指定分隔符集。 这将替换空格和制表符的默认分隔符集。 |
    | 标记 =`<x,y,m–n>` | 指定每行的哪些标记要传递到每个迭代的**for**循环。 因此，将分配更多的变量名称。 *m-n*指定从*m*到第*n*个标记的范围。 如果**标记 =** 字符串中的最后一个字符是星号（**&#42;**），则分配一个额外的变量，并在分析的最后一个标记之后的行上接收剩余的文本。 |
    | usebackq | 指定以命令形式运行带引号的字符串，将带引号的字符串用作文本字符串; 或者，对于包含空格的长文件名，允许在中使用文件名， `<set>` 每个名称都括在双引号中。 |

  - **变量替换：** 下表列出了可选语法（适用于任何变量**I**）：

    | 带有修饰符的变量 | 说明 |
    | ---------------------- | ----------- |
    |` %~I` | 展开 `%I` 可删除任何周围引号。 |
    | `%~fI `| 扩展 `%I` 到完全限定的路径名称。 |
    | `%~dI `| `%I`仅扩展到驱动器号。 |
    | `%~pI` | `%I`仅展开为路径。 |
    | `%~nI `| `%I`仅扩展到文件名。 |
    | `%~xI` | `%I`仅扩展到文件扩展名。 |
    | `%~sI` | 将路径展开为仅包含短名称。 |
    | `%~aI` | 扩展 `%I` 到文件的文件属性。 |
    | `%~tI` | 扩展 `%I` 到文件的日期和时间。 |
    | `%~zI` | 扩展 `%I` 到文件的大小。 |
    | `%~$PATH:I` | 搜索 PATH 环境变量中列出的目录，并将其扩展 `%I` 到找到的第一个目录的完全限定名称。 如果未定义环境变量名称或搜索找不到该文件，此修饰符将扩展为空字符串。 |

    下表列出了可用于获取复合结果的修饰符组合。

    | 包含组合修饰符的变量 | 说明 |
    | -------------------------------- | ----------- |
    | `%~dpI `| `%I`仅扩展到驱动器号和路径。 |
    | `%~nxI` | `%I`仅扩展到文件名和扩展名。 |
    | `%~fsI` | `%I`将扩展为仅带有短名称的完整路径名称。 |
    | `%~dp$PATH:I` | 搜索 PATH 环境变量中列出的目录，并将其 `%I` 扩展到找到的第一个驱动器号和路径。 |
    | `%~ftzaI` | 展开 `%I` 为类似于**dir**的输出行。 |

    在上述示例中，可以将替换 `%I` 为其他有效值，并将其替换为路径。 **变量名称**的有效结尾为 **%~** 语法。

    通过使用大写变量名称（如 `%I` ），可以使代码更具可读性，并避免与不区分大小写的修饰符混淆。

- **分析字符串：** 可以 `for /f` 通过以下两种方式使用分析逻辑 `<literalstring>` ：双引号（*无*usebackq）或单引号（*带有*usebackq）--例如，（MyString）或（' MyString '）。 `<literalstring>`被视为来自文件的单个行输入。 当 `<literalstring>` 在双引号中进行分析时，命令符号（如 `\ & | > < ^` ）被视为普通字符。

- **分析输出：** 您可以使用 `for /f` 命令来分析命令的输出，方法是在括号之间放置一个反引号 `<command>` 。 它被视为传递给子 Cmd.exe 的命令行。 将输出捕获到内存中，并将其作为文件进行分析。

## <a name="examples"></a>示例

若要**在批处理**文件中使用，请使用以下语法：

```
for {%%|%}<variable> in (<set>) do <command> [<commandlineoptions>]
```

若要使用可替换变量 **% f**显示当前目录中所有文件的内容，该文件的扩展名为 .doc 或 .txt，请键入：

```
for %f in (*.doc *.txt) do type %f
```

在前面的示例中，当前目录中具有 .doc 或 .txt 扩展名的每个文件都将替换 **% f**变量，直到显示每个文件的内容。 若要在批处理文件中使用此命令，请将 **% f**的每个匹配项替换为 **%% f**。 否则，将忽略该变量并显示一条错误消息。

若要分析文件，忽略注释行，请键入：

```
for /f eol=; tokens=2,3* delims=, %i in (myfile.txt) do @echo %i %j %k
```

此命令分析*myfile.txt*中的每一行。 它将忽略以分号开头的行，并将每一行的第二个和第三个标记传递到**for**正文（标记之间用逗号或空格分隔）。 **For**语句的主体引用 **% i**获取第二个标记， **% j**获取第三个标记，并为 **% k**以获取所有剩余标记。 如果提供的文件名包含空格，请使用引号将文本括起来（例如，文件名）。 若要使用引号，必须使用**usebackq**。 否则，引号被解释为定义要分析的文本字符串。

已在**for**语句中显式声明了 **% i** 。 **% j**和 **% k**使用**标记 =** 隐式声明。 您可以使用**标记 =** 来指定最多26个标记，前提是它不会导致将变量声明为大于字母 Z 或 z 的尝试。

若要分析命令的输出，请*将集*放在括号之间，键入：

```
for /f usebackq delims== %i in ('set') do @echo %i
```

## <a name="additional-references"></a>其他参考

- [命令行语法项](command-line-syntax-key.md)
